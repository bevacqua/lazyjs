{"name":"LazyJS","tagline":"The minimalist JavaScript loader","body":"# LazyJS #\r\n\r\n**LazyJS** is an alternative to CommonJS/Modules and RequireJS with a minimal design that allows you to make your own decisions, rather than trying to force them on you.\r\n\r\n# Concept #\r\n\r\nThe idea with LazyJS is very similar to what RequireJS aims at, which is dependencies that resolve themselves. The difference is LazyJS aims to be less intrusive in how you should style your code, and lets you determine how to handle dependencies beyond the physical modules you use.\r\n\r\n## Getting Prepared ##\r\n\r\nIf you care about contributing, you can either download the code using `git`, or through `npm`.\r\n\r\n    git clone https://github.com/bevacqua/lazyjs.git\r\n    \r\n    npm install lazyjs\r\n    \r\nLazyJS has a one-step build process powered by [Grunt](http://gruntjs.com/).\r\n\r\nUse `grunt demo` to see the concept in action, `grunt build` to build, `grunt tests` for tests.\r\n\r\n## Getting Started with LazyJS ##\r\n\r\nUsing LazyJS, you only need to embed a single `<script>` tag in your HTML\r\n\r\n    <script id='lazyjs' src='/js/vendor/lazy.min.js' data-jumpstart='/js/app.js'></script>\r\n\r\nThis `<script>` tag will allow LazyJS to load via AJAX the script you reference in the `data-jumpstart` attribute. That's familiar enough, RequireJS behaves similarly.\r\n\r\nWithin scripts, though, there are differences. LazyJS uses what's called **comment directives**. There's two types of these directives.\r\n\r\n    \r\n- `define` directives, which allow us to define _multiple modules in a single file_:\r\n\r\n    ```js\r\n    /*! lazy define $name */\r\n    ```\r\n\r\n    ```js\r\n    /*! lazy define module-1 */\r\n    function sum(a, b){\r\n        return a + b;\r\n    }\r\n\r\n    /*! lazy define module-2 */\r\n    function print(text){\r\n        console.log(text);\r\n    }\r\n    ```\r\n\r\n**Definitions** mean that your modules will now be identified by whatever name `$name` you pick\r\n    \r\n- `require` directives, which make a module **depend on another one**:\r\n\r\n    ```js\r\n    /*! lazy require $name */\r\n    ```\r\n\r\n    ```js\r\n    /*! lazy define module-3 */\r\n    /*! lazy require module-1 */\r\n    /*! lazy require module-2 */\r\n    function funky(){\r\n        print('the result is ' + sum(5, -2));\r\n    }\r\n    ```\r\n\r\n**Dependency**, as defined by `require` comment directives, means that the code in a module won't be evaluated _at all_ until every single dependency has been evaluated and resolved.\r\n\r\n## Getting Practical ##\r\n\r\nIn a more practical scenario, you would probably want to completely skip module definitions, and stick to the _one-module-per-file_ convention, where if you had a script at `/js/foo.js`, you could add a `require` directive like the one below.\r\n\r\n```js\r\n/*! lazy require /js/foo.js */\r\n```\r\n\r\nIf you stick to one module per file, `define` directives are not necessary (during development). These do become crucial when you are bundling your scripts together, though.\r\n\r\n## Getting Real ##\r\n\r\nIn a production scenario you don't want all those AJAX requests flying around. So you change things up very subtly:\r\n\r\n```js\r\n    <script id='lazyjs' src='/js/vendor/lazy.min.js' data-jumpstart='/js/app.js' data-bundle='js/all.js'></script>\r\n```\r\n\r\nThis might be kind of deceiving at first glance, but it will just perform two HTTP requests. One for LazyJS, and the other one for everything else. But here's the beauty.\r\n\r\nEven though we've now fetched every single line of JavaScript, we are not going to evaluate it yet, we are just storing the strings, after some manipulation to figure out which module is which, and which module needs what. We don't even split the string until we need it.\r\n\r\nThis approach **drastically increases average load times**, and that's even when the script is cached and gzipped (as they should be). That's because JS parsing can take up a significant time on each page load. Time that might be better spent elsewhere, or _better distributed_.\r\n\r\nOk, but what happens to the jump-start script now? Well, it's essentially the same scenario as it was before using bundles, except now you have a nice hashtable with a list of modules that are eager to be evaluated. If `/js/app.js` is among those scripts, it will be parsed and executed immediately, if it's not, then the usual AJAX request would go get it.\r\n\r\nIf an script has any number of dependencies, then those will be resolved, recursively, until all dependencies are resolved and the script can load. Then, everything gets evaluated.\r\n\r\nNote that modules will only be fetched/parsed/evaluated once. Just like when you don't have the aid of a script loader.\r\n\r\n# Disclaimer #\r\n\r\nThis is the early prototype of an idea, an experiment if you will. Hopefully I'll get some input on it's viability, and then decide where the project will go from there.\r\n\r\nSuggestions are welcome!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}